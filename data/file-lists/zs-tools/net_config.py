import os
import time
import glob


import shell
import utils
from log import get_logger

logger = get_logger(__name__)


ZSTACK_START_COMMENT = "# Generated by zstack customization engine. Do not edit."

NET_CONFIG_IPV4 = 4
NET_CONFIG_IPV6 = 6

NET_CONFIG_MTU_MIN = 576
NET_CONFIG_MTU_MAX = 9000
NET_CONFIG_MTU_DEFAULT = 1500

NET_CONFIG_HA_STATE_ENABLED = 'Enabled'
NET_CONFIG_HA_STATE_DISCONNECTING = 'Disconnecting'
NET_CONFIG_HA_STATE_RECONECTING = 'Reconnecting'
NET_CONFIG_HA_STATE_DISABLED = 'Disabled'

NET_CONFIG_BOND_TYPE = 'BOND'
NET_CONFIG_ETHER_TYPE = 'ETHER'

NET_CONFIG_BOOTPROTO_STATIC = 'static'
NET_CONFIG_BOOTPROTO_DHCP = 'dhcp'
NET_CONFIG_BOOTPROTO_NONE = 'none'

NET_CONFIG_YES = 'yes'
NET_CONFIG_NO = 'no'

NET_CONFIG_OPERATE_STOP = 'stop'
NET_CONFIG_OPERATE_START = 'start'
NET_CONFIG_OPERATE_RELOAD = 'reload'

INTERFACES_FILE_PATH = '/etc/network/interfaces'

DEFAULT_CONFIG_PATH = '/etc/sysconfig/network-scripts'
DEFAULT_SIMILAR_CONFIG_PATH = '/etc/sysconfig/network'
NETWORKMANAGER_NATIVE_CONFIG_PATH = '/etc/NetworkManager/system-connections'
NETPLAN_CONFIG_PATH = '/etc/netplan'
NETWORKING_CONFIG_PATH = '/etc/network'

NET_SERVICE_TYPE_NMCLI = 'NetworkManager'
NET_SERVICE_TYPE_NETWORK = 'network'
NET_SERVICE_TYPE_NETWORKING = 'networking'
NET_SERVICE_TYPE_NETPLAN = 'netplan'

RESOLV_CONF_PATH = '/etc/resolv.conf'


def call_shell_if_err_raise(cmd):
    ret_code, stdout, stderr = shell.call(cmd)
    if ret_code != 0:
        raise NetConfigError(stderr)
    return stdout


def execute_command(cmd_template, *args):
    cmd = cmd_template % args
    shell.call(cmd)


def get_system_network_service():
    '''get system network service'''
    net_service = {}
    if is_nmcli_running():
        if is_netplan_running():
            net_service['type'] = NET_SERVICE_TYPE_NETPLAN
            net_service['path'] = NETPLAN_CONFIG_PATH
            return net_service

        net_service['type'] = NET_SERVICE_TYPE_NMCLI
        if os.path.isdir(DEFAULT_CONFIG_PATH):
            net_service['path'] = DEFAULT_CONFIG_PATH
        elif os.path.isdir(DEFAULT_SIMILAR_CONFIG_PATH):
            net_service['path'] = DEFAULT_SIMILAR_CONFIG_PATH
        elif os.path.isdir(NETWORKMANAGER_NATIVE_CONFIG_PATH):
            net_service['path'] = NETWORKMANAGER_NATIVE_CONFIG_PATH
        return net_service

    if os.path.isdir(DEFAULT_CONFIG_PATH):
        net_service['type'] = NET_SERVICE_TYPE_NETWORK
        net_service['path'] = DEFAULT_CONFIG_PATH
        return net_service

    if os.path.isdir(DEFAULT_SIMILAR_CONFIG_PATH):
        net_service['type'] = NET_SERVICE_TYPE_NETWORK
        net_service['path'] = DEFAULT_SIMILAR_CONFIG_PATH
        return net_service

    if is_netplan_running():
        net_service['type'] = NET_SERVICE_TYPE_NETPLAN
        net_service['path'] = NETPLAN_CONFIG_PATH
        return net_service

    if os.path.isdir(NETWORKING_CONFIG_PATH):
        net_service['type'] = NET_SERVICE_TYPE_NETWORKING
        net_service['path'] = NETWORKING_CONFIG_PATH
        return net_service

    return net_service


def is_nmcli_running():
    '''is NetworkManager running'''
    if shell.run('nmcli con'):
        return True

    return False


def is_netplan_running():
    '''is netplan running'''
    if shell.run('which netplan'):
        return True

    return False


class NetConfigError(Exception):
    '''net config error'''


class IpConfig(object):
    '''netconfig: ip config'''

    def __init__(self, ip, netmask, gateway=None, version=NET_CONFIG_IPV4):
        self.ip = ip
        self.netmask = netmask
        self.gateway = gateway
        self.version = version


class RouteConfig(object):
    '''netconfig: route config'''

    def __init__(self, prefix, nexthop, dev, version=NET_CONFIG_IPV4):
        self.prefix = prefix
        self.nexthop = nexthop
        self.dev = dev
        self.version = version


class NetConfig(object):
    '''netconfig: net config'''

    def __init__(self, name, link_type=None, service_type=None, config_path=None):
        self.name = name
        self.device = name
        self.mac = None
        self.link_type = link_type
        self.boot_mode = NET_CONFIG_YES
        self.boot_proto = NET_CONFIG_BOOTPROTO_STATIC
        self.peer_dns = NET_CONFIG_NO
        self.mtu = None
        self.alias = None
        self.ip_configs = []
        self.route_configs = []
        self.dns_servers = []
        self.dns6_servers = []
        self.service_type = service_type
        self.config_path = config_path
        self.standby_nic_name = None

    def add_ip_config(self, ip, netmask, version=NET_CONFIG_IPV4, gateway=None):
        '''add ip config'''
        ip_config = None
        for item in self.ip_configs:
            if item.ip == ip:
                ip_config = item
                break
        if ip_config is None:
            ip_config = IpConfig(ip=ip, netmask=netmask)

        if gateway:
            ip_config.gateway = gateway
        ip_config.version = version
        self.ip_configs.append(ip_config)

    def add_route_config(self, prefix, nexthop, dev=None, version=NET_CONFIG_IPV4):
        '''add route config'''
        route_config = None
        for item in self.route_configs:
            if item.prefix == prefix:
                route_config = item
                break
        if route_config is None:
            route_config = RouteConfig(prefix=prefix, nexthop=nexthop, dev=dev, version=version)
            self.route_configs.append(route_config)

    def add_dns_config(self, dns):
        '''add dns config'''
        if not dns:
            return
        if utils.is_ipv4(dns):
            for item in self.dns_servers:
                if item == dns:
                    return
            self.dns_servers.append(dns)
        else:
            for item in self.dns6_servers:
                if item == dns:
                    return
            self.dns6_servers.append(dns)

    def check_config(self):
        if not self.name or len(self.name) > 15:
            raise NetConfigError('configure error, netdev name must be between 1 and 15 characters')
        if not self.link_type:
            raise NetConfigError('configure error, can not get link type')
        if self.mtu and (self.mtu < NET_CONFIG_MTU_MIN or self.mtu > NET_CONFIG_MTU_MAX):
            raise NetConfigError('configure error, netdev mtu must be between 576 and 9000')
        if not self.boot_mode or not self.boot_proto:
            raise NetConfigError('configure error, boot mode and boot protocol must be specified')
        if self.boot_mode not in [NET_CONFIG_YES, NET_CONFIG_NO]:
            raise NetConfigError('configure error, boot mode must be yes or no')
        if self.boot_proto not in [NET_CONFIG_BOOTPROTO_STATIC, NET_CONFIG_BOOTPROTO_DHCP, NET_CONFIG_BOOTPROTO_NONE]:
            raise NetConfigError('configure error, boot protocol must be static, dhcp or none')
        if self.boot_proto == NET_CONFIG_BOOTPROTO_DHCP and self.ip_configs:
            raise NetConfigError('configure error, unable to set ip when boot protocol is [dhcp]')
        if not self.config_path:
            raise NetConfigError('configure error, could not get network config path')
        if not self.service_type:
            raise NetConfigError('configure error, could not get network service type')

        for ip_config in self.ip_configs:
            if not ip_config.ip or not ip_config.netmask:
                raise NetConfigError('configure error, ip or netmask is empty')
            if ip_config.version == NET_CONFIG_IPV4 and not utils.is_ipv4(ip_config.ip):
                raise NetConfigError('configure error, ip[%s] is not ipv4 address' % ip_config.ip)

    def check_network(self, _):
        '''netconfig: check network'''
        if not self.name:
            raise NetConfigError('configure error, nic name must be specified')
        ip_info = utils.get_nic_info_by_name(self.name)
        if not ip_info:
            raise NetConfigError('configure error, could not get nic[%s] info' % self.name)
        current_ips = ip_info.get('ipv4', []) + ip_info.get('ipv6', [])
        for ip_config in self.ip_configs:
            is_exist = False
            for item in current_ips:
                if item['address'] == ip_config.ip:
                    logger.debug('netconfig: ip[%s] is exist on nic[%s]' % (ip_config.ip, self.name))
                    is_exist = True
                    break
            if not is_exist:
                logger.debug('netconfig: ip[%s] not exist on nic[%s]' % (ip_config.ip, self.name))
                return False

        return True

    def make_standby_instance(self):
        standby_instance = NetConfig(self.standby_nic_name,
                                     link_type=NET_CONFIG_ETHER_TYPE,
                                     service_type=self.service_type,
                                     config_path=self.config_path)
        standby_instance.mtu = self.mtu
        standby_instance.mac = self.mac
        standby_instance.ip_configs = self.ip_configs
        standby_instance.dns_servers = self.dns_servers
        standby_instance.dns6_servers = self.dns6_servers
        standby_instance.route_configs = self.route_configs
        return standby_instance

    def make_nic_config_file_path(self, nic_name):
        '''netconfig: make config file name'''
        if not nic_name:
            return None
        if self.config_path in [DEFAULT_CONFIG_PATH, DEFAULT_SIMILAR_CONFIG_PATH]:
            return os.path.join(self.config_path, 'ifcfg-%s' % nic_name)
        elif self.config_path == NETWORKMANAGER_NATIVE_CONFIG_PATH:
            return os.path.join(self.config_path, '%s.nmconnection' % nic_name)
        elif self.config_path == NETPLAN_CONFIG_PATH:
            return os.path.join(self.config_path, '99-zstack-net-%s.yaml' % nic_name)
        elif self.config_path == NETWORKING_CONFIG_PATH:
            return INTERFACES_FILE_PATH
        return None

    def config_static_routes_base(self):
        '''netconfig: config static routes'''
        for route_config in self.route_configs:
            execute_command('ip -%s route add %s via %s dev %s metric 181', route_config.version, route_config.prefix, route_config.nexthop, self.name)

    def config_network_base(self):
        '''netconfig: config network'''
        nic_info = utils.get_nic_info_by_name(self.name)
        if not nic_info:
            raise NetConfigError('configure error, could not get nic[%s] info' % self.name)
        logger.debug('netconfig: nic[%s] info: %s' % (self.name, nic_info))

        if nic_info['state'] != 'UP':
            execute_command('ip link set %s up', self.name)

        if nic_info['mtu'] != self.mtu:
            execute_command('ip link set %s mtu %s', self.name, self.mtu)

        is_ignore_linkdown_route = False
        ignore_route_path = '/proc/sys/net/ipv4/conf/%s/ignore_routes_with_linkdown' % self.name
        if os.path.exists(ignore_route_path):
            is_ignore_linkdown_route = True
            execute_command('echo 1 > %s' % ignore_route_path)

        ipv4_info = nic_info.get('ipv4', [])
        ipv6_info = nic_info.get('ipv6', [])

        for ip_config in self.ip_configs:
            if ip_config.version == NET_CONFIG_IPV4:
                is_exist = False
                for item in ipv4_info:
                    if item['address'] == ip_config.ip:
                        logger.debug('netconfig: ip[%s] is exist on nic[%s]' % (ip_config.ip, self.name))
                        is_exist = True
                        break
                if not is_exist:
                    ip4_addr = '%s/%s' % (ip_config.ip, ip_config.netmask)
                    execute_command('ip -%s addr add %s dev %s brd +', NET_CONFIG_IPV4, ip4_addr, self.name)
                if ip_config.gateway:
                    execute_command('ip -%s route add default via %s dev %s metric 181', NET_CONFIG_IPV4, ip_config.gateway, self.name)
            else:
                is_exist = False
                for item in ipv6_info:
                    if item['address'] == ip_config.ip:
                        logger.debug('netconfig: ip[%s] is exist on nic[%s]' % (ip_config.ip, self.name))
                        is_exist = True
                        break
                if not is_exist:
                    ip6_addr = '%s/%s' % (ip_config.ip, ip_config.netmask)
                    execute_command('ip -%s addr add %s dev %s', NET_CONFIG_IPV6, ip6_addr, self.name)
                if ip_config.gateway:
                    execute_command('ip -%s route add default via %s dev %s metric 181', NET_CONFIG_IPV6, ip_config.gateway, self.name)

        # config direct route
        if not is_ignore_linkdown_route:
            code, stdout, _ = shell.call('ip route show dev %s' % self.name)
            if code == 0 and stdout:
                routes = stdout.split('\n')
                for route in routes:
                    if not route or 'metric' in route or '169.254.169.254' in route:
                        continue
                    execute_command('ip route add %s dev %s metric 181 && ip route del %s dev %s', route, self.name, route, self.name)

        self.config_static_routes_base()

    def pre_restore_config(self):
        '''netconfig: pre restore config'''
        if not self.config_path or not self.name:
            raise NetConfigError('configure error, config path and name must be specified')

        file_path = self.make_nic_config_file_path(self.name)
        if not file_path or not os.path.exists(file_path):
            return
        if self.config_path == NETWORKMANAGER_NATIVE_CONFIG_PATH:
            os.remove(file_path)
        else:
            os.rename(file_path, '%s.bak' % file_path)


    def restore_config_file(self, content):
        '''netconfig: load config file'''
        if not content:
            return

        config_file_path = self.make_nic_config_file_path(self.name)
        if not config_file_path:
            raise NetConfigError('configure error, config file path is empty')
        logger.debug('netconfig: type: %s, ifcfg file path: %s, content: %s' % (self.service_type, config_file_path, content))
        with open(config_file_path, 'w') as file:
            file.write(content)

    def post_restore_config(self):
        '''netconfig: post restore config'''
        return

    def common_config_network(self, ha_state):
        '''netconfig: common config network'''
        config_object = None
        if self.config_path in [DEFAULT_CONFIG_PATH, DEFAULT_SIMILAR_CONFIG_PATH]:
            config_object = NetConfigStyleRedhat(self)
        if self.config_path == NETWORKMANAGER_NATIVE_CONFIG_PATH:
            config_object = NetConfigStyleNetworkManager(self)
        elif self.config_path == NETPLAN_CONFIG_PATH:
            config_object = NetConfigStyleNetplan(self)
        elif self.config_path == NETWORKING_CONFIG_PATH:
            config_object = NetConfigStyleNetworking(self)

        if not config_object:
            raise NetConfigError('configure error, could not find configure instance')

        config_object.config_network(ha_state)

class NetConfigStyleRedhat(object):
    '''netconfig: net config style redhat'''

    def __init__(self, instance):
        self.instance = instance
        self.config_dict = None

    def add_config(self, key, value):
        '''netconfig: add config(key=value) to config_dict'''
        if self.config_dict is None:
            self.config_dict = SimpleOrderedDict()
        if not key or not value:
            return
        self.config_dict[key] = value

    def check_config(self):
        '''netconfig: check config'''
        if not self.instance:
            raise NetConfigError('configure error, instance is not initialized')
        self.instance.check_config()

    def set_link_state(self, operate=None):
        '''netconfig: post restore config'''
        if not operate:
            raise NetConfigError('configure error, operate must be spefied')

        if self.instance.service_type == NET_SERVICE_TYPE_NMCLI:
            if operate == NET_CONFIG_OPERATE_RELOAD:
                execute_command('nmcli c down %s; nmcli c up %s', self.instance.name, self.instance.name)
            elif operate == NET_CONFIG_OPERATE_STOP:
                execute_command('nmcli c down %s; ip link set %s down', self.instance.name, self.instance.name)
            else:
                execute_command('nmcli c up id %s || nmcli c up %s', self.instance.name, self.instance.name)
        else:
            if operate == NET_CONFIG_OPERATE_RELOAD:
                execute_command('ifdown %s; ifup %s', self.instance.name, self.instance.name)
            elif operate == NET_CONFIG_OPERATE_STOP:
                execute_command('ifdown %s', self.instance.name)
            else:
                execute_command('ifup %s', self.instance.name)

    def build_config_file(self):
        '''netconfig: build config file'''
        # build base config
        self.add_config('NAME', self.instance.name)
        self.add_config('DEVICE', self.instance.device if self.instance.device else self.instance.name)
        if self.instance.config_path == DEFAULT_SIMILAR_CONFIG_PATH:
            self.add_config('STARTMODE', 'auto')
            self.add_config('ZONE', 'public')
        else:
            self.add_config('ONBOOT', self.instance.boot_mode)
        self.add_config('BOOTPROTO', self.instance.boot_proto)
        self.add_config('USERCTL', 'no')
        self.add_config('PEERDNS', self.instance.peer_dns)
        if self.instance.mtu:
            self.add_config('MTU', self.instance.mtu)
        if self.instance.alias:
            self.add_config('ALIAS', '"{}"'.format(self.instance.alias))

        # only for ethernet
        if self.instance.link_type == NET_CONFIG_ETHER_TYPE:
            self.add_config('TYPE', 'Ethernet')
            if self.instance.mac:
                self.add_config('HWADDR', self.instance.mac)

        # build ip config
        for ip_config in self.instance.ip_configs:
            if ip_config.version == NET_CONFIG_IPV4:
                self.add_config('IPV4_FAILURE_FATAL', 'no')
                self.add_config('IPADDR', ip_config.ip)
                self.add_config('NETMASK', ip_config.netmask)
                if ip_config.gateway:
                    self.add_config('GATEWAY', ip_config.gateway)
                    self.add_config('DEFROUTE', 'yes')
            else:
                ip6_addr = '%s/%s' % (ip_config.ip, ip_config.netmask)
                self.add_config('IPV6INIT', 'yes')
                self.add_config('IPV6_AUTOCONF', 'no')
                self.add_config('IPV6_FAILURE_FATAL', 'no')
                if self.instance.config_path == DEFAULT_SIMILAR_CONFIG_PATH:
                    self.add_config('IPADDR2', ip6_addr)
                else:
                    self.add_config('IPV6ADDR', ip6_addr)
                    if ip_config.gateway:
                        self.add_config('IPV6_DEFAULTGW', ip_config.gateway)

        # build dns config
        all_dns_servers = self.instance.dns_servers + self.instance.dns6_servers
        if all_dns_servers:
            self.add_config('PEERDNS', 'yes')
            for index, dns in enumerate(all_dns_servers, start=1):
                self.add_config('DNS%d' % index, dns)

        config_list = [ZSTACK_START_COMMENT]
        config_list.extend(['%s=%s' % (k, v) for k, v in self.config_dict.items()])

        return '\n'.join(config_list) + '\n'

    def pre_restore_config(self):
        self.instance.pre_restore_config()

    def post_restore_config(self):
        self.instance.post_restore_config()

        if self.instance.standby_nic_name:
            standby_file_path = self.instance.make_nic_config_file_path(self.instance.standby_nic_name)
            if standby_file_path and os.path.exists(standby_file_path):
                os.remove(standby_file_path)
            if self.instance.service_type == NET_SERVICE_TYPE_NMCLI:
                execute_command('nmcli device set %s managed no', self.instance.standby_nic_name)

        if self.instance.config_path == DEFAULT_CONFIG_PATH:
            route_file_path = '%s/route-%s' % (self.instance.config_path, self.instance.name)
            if os.path.exists(route_file_path):
                os.rename(route_file_path, '%s.bak' % route_file_path)
            route_list = []
            if 'GATEWAY' in self.config_dict:
                for route in self.instance.route_configs:
                    route_list.append('%s via %s' % (route.prefix, route.nexthop))
            if route_list:
                route_content = '\n'.join(route_list) + '\n'
                with open(route_file_path, 'w') as file:
                    file.write(route_content)

        if self.instance.config_path == DEFAULT_SIMILAR_CONFIG_PATH:
            route_list = []
            if 'GATEWAY' in self.config_dict:
                route_list.append('default %s' % self.config_dict['GATEWAY'])
                for route in self.instance.route_configs:
                    route_list.append('%s %s' % (route.prefix, route.nexthop))

            route_file_path = '%s/ifroute-%s' % (self.instance.config_path, self.instance.name)
            if os.path.exists(route_file_path):
                os.rename(route_file_path, '%s.bak' % route_file_path)
            if route_list:
                route_content = '\n'.join(route_list) + '\n'
                with open(route_file_path, 'w') as file:
                    file.write(route_content)

        if self.instance.service_type == NET_SERVICE_TYPE_NMCLI:
            execute_command('nmcli c reload')

    def restore(self):
        '''restore config'''
        self.check_config()
        self.pre_restore_config()
        content = self.build_config_file()
        if not content:
            raise NetConfigError('configure error, content is empty')

        self.instance.restore_config_file(content)
        self.post_restore_config()

    def apply(self):
        '''apply config'''
        self.set_link_state(NET_CONFIG_OPERATE_START)
        utils.wait_callback_success(self.instance.check_network, callback_data=None)

    def config_network(self, ha_state):
        '''netconfig: config network'''
        if ha_state == NET_CONFIG_HA_STATE_ENABLED:
            self.instance.mac = None
            self.restore()
            self.instance.config_network_base()

            if self.instance.standby_nic_name:
                standby_instance = self.instance.make_standby_instance()
                # config standby nic by iproute
                standby_instance.config_network_base()
        elif ha_state == NET_CONFIG_HA_STATE_DISCONNECTING:
            self.instance.config_network_base()
        else:
            self.restore()
            self.instance.config_network_base()


class NetConfigStyleNetworkManager(object):
    '''netconfig: net config style networkmanager'''

    def __init__(self, instance):
        self.instance = instance

    def check_config(self):
        if not self.instance:
            raise NetConfigError('configure error, instance is not initialized')
        self.instance.check_config()
        return

    def build_config_file(self):
        '''netconfig: build config file'''

        # build base config
        content_list = ['[connection]', 'id=%s' % self.instance.name, 'type=ethernet', 'autoconnect=true']
        content_list.append('')

        # build mac config
        if self.instance.mac:
            content_list.extend(['[ethernet]', 'mac-address=%s' % self.instance.mac])
            content_list.append('')
        ipv4_config = [ip for ip in self.instance.ip_configs if ip.version == NET_CONFIG_IPV4]
        ipv6_config = [ip for ip in self.instance.ip_configs if ip.version == NET_CONFIG_IPV6]

        # build ipv4 config
        content_list.extend(['[ipv4]', 'method=auto']) if not ipv4_config else content_list.extend(['[ipv4]', 'method=manual'])
        gateway_v4 = None
        for index, ip_config in enumerate(ipv4_config, start=1):
            content_list.append('address%d=%s/%s' % (index, ip_config.ip, utils.netmask_to_prefix(ip_config.netmask)))
            if ip_config.gateway and not gateway_v4:
                content_list.append('gateway=%s' % ip_config.gateway)
        if self.instance.dns_servers:
            content_list.append('dns=%s' % ';'.join(self.instance.dns_servers))
        for index, route_config in enumerate(self.instance.route_configs, start=1):
            if route_config.version == NET_CONFIG_IPV4:
                content_list.append('route%d=%s,%s' % (index, route_config.prefix, route_config.nexthop))
        content_list.append('')

        # build ipv6 config
        content_list.extend(['[ipv6]', 'method=auto']) if not ipv6_config else content_list.extend(['[ipv6]', 'method=manual'])
        gateway_v6 = None
        for index, ip_config in enumerate(ipv6_config, start=1):
            content_list.append('address%d=%s/%s' % (index, ip_config.ip, utils.netmask_to_prefix(ip_config.netmask)))
            if ip_config.gateway and not gateway_v6:
                content_list.append('gateway=%s' % ip_config.gateway)
        if self.instance.dns6_servers:
            content_list.append('dns=%s' % ';'.join(self.instance.dns6_servers))
        for index, route_config in enumerate(self.instance.route_configs, start=1):
            if route_config.version == NET_CONFIG_IPV6:
                content_list.append('route%d=%s,%s' % (index, route_config.prefix, route_config.nexthop))
        content_list.append('')

        return ZSTACK_START_COMMENT + '\n' + '\n'.join(content_list) + '\n'

    def post_restore_config(self):
        self.instance.post_restore_config()
        execute_command('nmcli c reload')

    def restore(self):
        '''netconfig: restore config'''
        self.check_config()
        self.instance.pre_restore_config()
        content = self.build_config_file()
        if not content:
            raise NetConfigError('configure error, content is empty')
        self.instance.restore_config_file(content)
        self.post_restore_config()

    def apply(self):
        '''netconfig: apply config'''
        execute_command('nmcli c up %s', self.instance.name)
        utils.wait_callback_success(self.instance.check_network, callback_data=None)

    def config_network(self, ha_state):
        '''netconfig: config network'''

        if ha_state == NET_CONFIG_HA_STATE_ENABLED:
            self.instance.mac = None
            self.restore()
            self.apply()

            standby_instance = self.instance.make_standby_instance()
            # config standby nic by nmcli
            standby_instance.config_network_base()
        elif ha_state == NET_CONFIG_HA_STATE_DISCONNECTING:
            self.instance.config_network_base()
        else:
            self.restore()
            self.apply()


class NetConfigStyleNetplan(object):
    '''netconfig: net config style netplan'''

    def __init__(self, instance):
        self.instance = instance

    def check_config(self):
        if not self.instance:
            raise NetConfigError('configure error, instance is not initialized')
        self.instance.check_config()
        return

    def build_config_file(self):
        '''netconfig: build config file v2'''
        indent_level_1 = ' ' * 2
        indent_level_2 = indent_level_1 * 2
        indent_level_3 = indent_level_1 * 3
        indent_level_4 = indent_level_1 * 4

        config_list = []
        config_list.append(ZSTACK_START_COMMENT)

        # build base config, indent level 0
        config_list.append('network:')

        # build network config, indent level 1
        config_list.append('%sversion: 2' % indent_level_1)
        # config_list.append('%srenderer: networkd' % indent_level_1)
        config_list.append('%sethernets:' % indent_level_1)

        # build nic config, indent level 2
        config_list.append('%s%s:' % (indent_level_2, self.instance.name))

        # build mac config, indent level 3
        if self.instance.mac:
            config_list.append('%s%s%s:' % (indent_level_3, 'match', ''))
            config_list.append('%smacaddress: %s' % (indent_level_4, self.instance.mac))
        config_list.append('%smtu: %s' % (indent_level_3, self.instance.mtu if self.instance.mtu else NET_CONFIG_MTU_DEFAULT))

        # build ip config, indent level 3
        ipv4_config = [ip for ip in self.instance.ip_configs if ip.version == NET_CONFIG_IPV4]
        ipv6_config = [ip for ip in self.instance.ip_configs if ip.version == NET_CONFIG_IPV6]
        if ipv4_config:
            config_list.append('%sdhcp4: no' % indent_level_3)
            config_list.append('%saddresses:' % indent_level_3)
            gateway_v4 = None
            for ip_config in ipv4_config:
                prefix = utils.netmask_to_prefix(ip_config.netmask)
                config_list.append('%s- %s/%s' % (indent_level_3, ip_config.ip, prefix))
                if ip_config.gateway:
                    gateway_v4 = ip_config.gateway
            if gateway_v4:
                config_list.append('%sgateway4: %s' % (indent_level_3, gateway_v4))
        if ipv6_config:
            config_list.append('%sdhcp6: no' % indent_level_3)
            config_list.append('%saccept-ra: true' % indent_level_3)
            config_list.append('%saddresses:' % indent_level_3)
            gateway_v6 = None
            for ip_config in ipv6_config:
                prefix = utils.netmask_to_prefix(ip_config.netmask)
                config_list.append('%s- %s/%s' % (indent_level_3, ip_config.ip, prefix))
                if ip_config.gateway:
                    gateway_v6 = ip_config.gateway
            if gateway_v6:
                config_list.append('%sgateway6: %s' % (indent_level_3, gateway_v6))

        # build dns config, indent level 3
        all_dns_servers = self.instance.dns_servers + self.instance.dns6_servers
        if all_dns_servers:
            config_list.append('%snameservers:' % indent_level_3)
            config_list.append('%saddresses: [%s]' % (indent_level_4, ', '.join(all_dns_servers)))

        # build route config, indent level 3
        if self.instance.route_configs:
            route_entrys = []
            for route_config in self.instance.route_configs:
                entry = '{to: %s, via: %s}' % (route_config.prefix, route_config.nexthop)
                route_entrys.append(entry)
            if route_entrys:
                route_entrys_str = '[' + ', '.join(route_entrys) + ']'
                config_list.append('%sroutes: %s' % (indent_level_3, route_entrys_str))

        return '\n'.join(config_list) + '\n'

    def post_restore_config(self):
        self.instance.post_restore_config()

        if not os.path.exists(NETPLAN_CONFIG_PATH):
            return
        files = glob.glob('%s/*.yaml' % NETPLAN_CONFIG_PATH)
        for file in files:
            with open(file, 'r') as fd:
                content = fd.read()
                if not utils.is_validate_netplan_config(content):
                    logger.debug('config path: %s, find file is invalid: %s' % (self.instance.config_path, file))
                    os.rename(file, '%s_bak' % file)

    def restore(self):
        '''netconfig: restore config'''
        self.check_config()
        self.instance.pre_restore_config()
        content = self.build_config_file()
        if not content:
            raise NetConfigError('configure error, content is empty')
        self.instance.restore_config_file(content)
        self.post_restore_config()

    def apply(self):
        '''netconfig: apply netplan config'''
        execute_command('netplan apply')
        utils.wait_callback_success(self.instance.check_network, callback_data=None)

    def config_network(self, ha_state):
        '''netconfig: config network'''

        if ha_state == NET_CONFIG_HA_STATE_ENABLED:
            self.instance.mac = None
            self.restore()
            self.apply()

            standby_instance = self.instance.make_standby_instance()
            # config standby nic by ip link
            standby_instance.config_network_base()
        elif ha_state == NET_CONFIG_HA_STATE_DISCONNECTING:
            self.instance.config_network_base()
        else:
            self.restore()
            self.apply()


class NetConfigStyleNetworking(object):
    '''netconfig: net config style interfaces'''

    def __init__(self, instance):
        self.instance = instance
        self.falg_dict = SimpleOrderedDict() # eg: {'ens3': 'auto'}
        self.network_configs = [] # list of InetConfig
        self._parse_config_file()

    def format_to_string(self):
        format_str_list = [ZSTACK_START_COMMENT]

        for name, flag in self.falg_dict.items():
            format_str_list.append('%s %s' % (flag, name))
            for config in self.network_configs:
                if config.name == name:
                    format_str_list.append(config.format_to_string())

        return '\n'.join(format_str_list) + '\n'

    class InetConfig(object):
        def __init__(self, name, family, method):
            self.name = name
            self.family = family if family else 'inet'  # 'inet' or 'inet6'
            self.method = method if method else 'static'  # 'static', 'dhcp', 'manual', 'loopback'
            self.mtu = None
            self.address = None
            self.netmask = None
            self.gateway = None
            self.dns_nameservers = []
            self.pre_up_scripts = []
            self.up_scripts = []
            self.post_up_scripts = []
            self.pre_down_scripts = []
            self.down_scripts = []
            self.post_down_scripts = []

        def format_to_string(self):
            format_str_list = []
            format_str_list.append('iface %s %s %s' % (self.name, self.family, self.method))
            if self.mtu:
                format_str_list.append('  mtu %s' % self.mtu)
            if self.address:
                format_str_list.append('  address %s' % self.address)
            if self.netmask:
                format_str_list.append('  netmask %s' % self.netmask)
            if self.gateway:
                format_str_list.append('  gateway %s' % self.gateway)
            if self.dns_nameservers:
                format_str_list.append('  dns-nameservers %s' % ' '.join(self.dns_nameservers))
            if self.pre_up_scripts:
                for script in self.pre_up_scripts:
                    format_str_list.append('  pre-up %s' % script)
            if self.up_scripts:
                for script in self.up_scripts:
                    format_str_list.append('  up %s' % script)
            if self.post_up_scripts:
                for script in self.post_up_scripts:
                    format_str_list.append('  post-up %s' % script)
            if self.pre_down_scripts:
                for script in self.pre_down_scripts:
                    format_str_list.append('  pre-down %s' % script)
            if self.down_scripts:
                for script in self.down_scripts:
                    format_str_list.append('  down %s' % script)
            if self.post_down_scripts:
                for script in self.post_down_scripts:
                    format_str_list.append('  post-down %s' % script)

            return '\n'.join(format_str_list)

    def check_config(self):
        if not self.instance:
            raise NetConfigError('configure error, instance is not initialized')
        self.instance.check_config()
        return

    def _do_parse_config(self, content):
        lines = content.split('\n')
        current_config = None
        for line in lines:
            line_str = line.strip()
            if not line_str or line_str.startswith('#') or line_str.startswith('source') or line_str.startswith('mapping'):
                current_config = None
                continue
            if line_str.startswith('auto') or line_str.startswith('allow-'):
                if len(line_str.split()) != 2:
                    continue
                self.falg_dict[line_str.split()[1]] = line_str.split()[0]
                continue
            if line_str.startswith('iface'):
                if len(line_str.split()) < 2:
                    continue
                name = line_str.split()[1]
                if name not in self.falg_dict:
                    self.falg_dict[name] = 'auto'
                family = None
                method = None
                for elem in line_str.split():
                    if elem in ['inet', 'inet6']:
                        family = elem
                    elif elem in ['static', 'dhcp', 'manual', 'loopback']:
                        method = elem
                config = self.InetConfig(name, family, method)
                self.network_configs.append(config)
                current_config = config
                continue

            if not current_config:
                continue
            if line_str.startswith('mtu'):
                current_config.mtu = line_str.split()[1]
            elif line_str.startswith('address'):
                current_config.address = line_str.split()[1]
            elif line_str.startswith('netmask'):
                current_config.netmask = line_str.split()[1]
            elif line_str.startswith('gateway'):
                current_config.gateway = line_str.split()[1]
            elif line_str.startswith('dns-nameservers'):
                parts = line_str.split('dns-nameservers', 1)
                servers = parts[1].strip() if len(parts) > 1 else None
                current_config.dns_nameservers.append(servers) if servers else None
            elif line_str.startswith('pre-up'):
                parts = line_str.split('pre-up')
                script = parts[1].strip() if len(parts) > 1 else None
                current_config.pre_up_scripts.append(script) if script else None
            elif line_str.startswith('up'):
                parts = line_str.split('up', 1)
                script = parts[1].strip() if len(parts) > 1 else None
                current_config.up_scripts.append(script) if script else None
            elif line_str.startswith('post-up'):
                parts = line_str.split('post-up', 1)
                script = parts[1].strip() if len(parts) > 1 else None
                current_config.post_up_scripts.append(script) if script else None
            elif line_str.startswith('pre-down'):
                parts = line_str.split('pre-down', 1)
                script = parts[1].strip() if len(parts) > 1 else None
                current_config.pre_down_scripts.append(script) if script else None
            elif line_str.startswith('down'):
                parts = line_str.split('down', 1)
                script = parts[1].strip() if len(parts) > 1 else None
                current_config.down_scripts.append(script) if script else None
            elif line_str.startswith('post-down'):
                parts = line_str.split('post-down', 1)
                script = parts[1].strip() if len(parts) > 1 else None
                current_config.post_down_scripts.append(script) if script else None

    def _parse_config_file(self):
        self.check_config()
        if not os.path.exists(INTERFACES_FILE_PATH):
            return
        with open(INTERFACES_FILE_PATH, 'r') as fd:
            content = fd.read()
            self._do_parse_config(content)

    def build_config_file(self):
        '''netconfig: build config file'''
        self.network_configs = [config for config in self.network_configs if config.name != self.instance.name]
        if self.instance.name not in self.falg_dict:
            self.falg_dict[self.instance.name] = 'auto'

        for ip_config in self.instance.ip_configs:
            family = 'inet' if ip_config.version == NET_CONFIG_IPV4 else 'inet6'
            inet_config = self.InetConfig(self.instance.name, family, 'static')
            inet_config.mtu = self.instance.mtu if self.instance.mtu else NET_CONFIG_MTU_DEFAULT
            inet_config.address = ip_config.ip
            inet_config.netmask = ip_config.netmask
            if ip_config.gateway:
                inet_config.gateway = ip_config.gateway

            for route_config in self.instance.route_configs:
                if route_config.version == ip_config.version:
                    inet_config.up_scripts.append('ip -%s route add %s via %s' % (route_config.version, route_config.prefix, route_config.nexthop))

            if ip_config.version == NET_CONFIG_IPV4:
                inet_config.dns_nameservers = self.instance.dns_servers
            if ip_config.version == NET_CONFIG_IPV6:
                inet_config.dns_nameservers = self.instance.dns6_servers
                inet_config.post_up_scripts.append('sysctl -w net.ipv6.conf.%s.autoconf=1' % self.instance.name)

            self.network_configs.append(inet_config)

        return self.format_to_string()

    def post_restore_config(self):
        self.instance.post_restore_config()

    def restore(self):
        '''netconfig: restore config'''
        self.check_config()
        self.instance.pre_restore_config()
        content = self.build_config_file()
        if not content:
            raise NetConfigError('configure error, content is empty')
        self.instance.restore_config_file(content)
        self.post_restore_config()

    def apply(self):
        '''netconfig: apply config'''
        execute_command('ifup %s --force --ignore-errors || ifup %s', self.instance.name, self.instance.name)
        utils.wait_callback_success(self.instance.check_network, callback_data=None)

    def config_network(self, ha_state):
        '''netconfig: config network'''
        if ha_state == NET_CONFIG_HA_STATE_ENABLED:
            self.instance.mac = None
            self.restore()
            self.apply()

            standby_instance = self.instance.make_standby_instance()
            # config standby nic by ip link
            standby_instance.config_network_base()
        elif ha_state == NET_CONFIG_HA_STATE_DISCONNECTING:
            self.instance.config_network_base()
            return
        else:
            self.restore()
            self.apply()

class SimpleOrderedDict(object):
    def __init__(self):
        self._keys = []
        self._dict = {}

    def __setitem__(self, key, value):
        if key not in self._dict:
            self._keys.append(key)
        self._dict[key] = value

    def __getitem__(self, key):
        return self._dict[key]

    def __iter__(self):
        for key in self._keys:
            yield key

    def items(self):
        for key in self._keys:
            yield (key, self._dict[key])

    def __contains__(self, key):
        return key in self._dict

    def get(self, key, default=None):
        return self._dict.get(key, default)

import json
import os
import re
import ast
import sys
from collections import namedtuple

import shell
import utils
import net_config as netconfig
from log import get_logger
from log import log_exce_traceback

ZSTACK_START_COMMENT = "# This file is auto generated by ZStack. Do not edit."

WORK_DIR = '/usr/local/zstack'

CONFIG_ARGUMENTS_PATH = WORK_DIR + '/zs-nics.json'

logger = get_logger(__name__)

g_nw_config_persist_func_tbl = {}

g_nw_config_reload_func_tbl = {}

g_nw_config_func_tbl = []

############################################################################

NwConfigFuncTableRecordFileds = [
    'os_id',
    'os_version_id',
    'use_netplan',
    'service',
    'persist_style',
    'persist_func',
    'reload_func'
]

NwConfigFuncTableRecord = namedtuple('NwConfigFuncTableRecord', NwConfigFuncTableRecordFileds)


def _get_nw_config_func_record(os_id=None,
                               os_version_id=None,
                               use_netplan=False,
                               service=None,
                               persist_style=None):
    for record in g_nw_config_func_tbl:
        if record.os_id == os_id\
                and record.os_version_id == os_version_id\
                and record.use_netplan == use_netplan\
                and record.service == service\
                and record.persist_style == persist_style:
            return record
    raise ConfigException('no handler for os: {0} {1}, netplan:{2} nm:{3} nf:{4}'.format(os_id, os_version_id,
                                                                                    use_netplan, service,
                                                                                    persist_style))


############################################################################

class ConfigException(Exception):
    'config error'


def _call_if_err_raise(cmd):
    ret_code, stdout, stderr = shell.call(cmd)
    if ret_code != 0:
        raise ConfigException(stderr)
    return stdout


def _get_curr_port_list():
    curr_port_list = []
    port_info = _call_if_err_raise('ls /sys/class/net')
    if port_info:
        curr_port_list = [port for port in port_info.split('\n') if port != ""]
    return curr_port_list


############################################################################


class NetworkConfigPersistOperatorBase:
    @staticmethod
    def persist_config(nics):
        pass


'''
    for non-netplan
'''


class DebianNetworkConfigPersistOperator(NetworkConfigPersistOperatorBase):
    """ /etc/network/ """

    config_file_style = "/etc/network/"
    config_file_path = "/etc/network/interfaces"

    @staticmethod
    def _config_retain(nics):
        """
        net_config:    [], list of original co_get_current_confignfig file lines that need to be kept
        """
        net_config = []
        routes_config = []
        content = _read_config_file(DebianNetworkConfigPersistOperator.config_file_path)

        if not content:
            return net_config, routes_config

        """
        the ubuntu 'interfaces' file consists of zero or more "iface", "mapping", "auto", "allow-",
        "source" and "source-directory" stanzas.
        """
        keys = ['auto', 'allow-', 'source', 'source-directory', 'mapping', 'iface', 'up']
        new_port_list = [nic.get('nic_name') for nic in nics]
        curr_port_list = _get_curr_port_list()
        # whether in interface config context
        iface_context = False
        nic_name = None
        inet = None

        for line in content.split('\n'):
            # for configuration comparison
            if line.strip().startswith('#'):
                continue

            elements = [x for x in line.strip().split(' ') if x != '']
            key = elements[0].strip() if len(elements) > 0 else None

            # Not support sub config file
            if key in ['source', 'source-directory']:
                continue

            # Static route
            if key == 'up':
                routes_config.append(line)
                continue

            # info[1] == nic name, delete when nic has been deleted
            if key == 'auto' and\
                    (len(elements) < 2 or elements[1].strip() in new_port_list or
                     elements[1].strip() not in curr_port_list):
                continue

            if key == 'iface' and len(elements) == 4:
                nic_name = elements[1].strip()
                iface_context = True
            elif key in keys:
                iface_context = False

            # 1. keep user-defined configuration
            # 2. keep other interface configuration that does not exist new_port_list
            if not iface_context or \
                    (nic_name in curr_port_list and
                     nic_name not in new_port_list):
                net_config.append(line)

        return net_config, routes_config

    @staticmethod
    def _create_zstack_config(nics):
        config_temp = [ZSTACK_START_COMMENT]
        net_config, routes_config = DebianNetworkConfigPersistOperator._config_retain(nics)
        if net_config:
            config_temp.extend(net_config)

        for nic in nics:
            nic_name = nic.get('nic_name')
            config_temp.append("auto {0}".format(nic_name))
            for vmIp in nic['vmIps']:
                if '6' in str(vmIp.get('version')):
                    if vmIp.get('ip').lower() == 'none':
                        continue
                    config_temp.append("iface {0} inet6 {1}".format(nic_name, vmIp.get('proto')))
                else:
                    if vmIp.get('ip').lower() == 'none':
                        config_temp.append("iface {0} inet manual".format(nic_name))
                        continue
                    config_temp.append("iface {0} inet {1}".format(nic_name, vmIp.get('proto')))
                if nic.get('mtu'):
                    config_temp.append('  mtu {0}'.format(nic.get('mtu')))
                if vmIp.get('proto') == 'static':
                    config_temp.append('  address {0}'.format(vmIp.get('ip')))
                    config_temp.append('  netmask {0}'.format(vmIp.get('netmask')))
                    if vmIp.get('gateway'):
                        config_temp.append('  gateway {0}'.format(vmIp.get('gateway')))
                    if nic.get('isDefault') and vmIp.get('dns'):
                        config_temp.append('  dns-nameservers {0}'.format(' '.join(vmIp.get('dns'))))
                        lines = [ZSTACK_START_COMMENT]
                        for dns in vmIp.get('dns'):
                            lines.append('nameserver {0}'.format(dns))
                        content = '\n'.join(lines) + '\n'
                        _write_config_file('/etc/resolv.conf', content)
                    if '6' in str(vmIp.get('version')):
                        config_temp.append('  post-up sysctl -w net.ipv6.conf.{0}.autoconf=1'.format(nic_name))
                if vmIp.get('routes'):
                    for route in vmIp.get('routes'):
                        routes_config = [old_route for old_route in routes_config if route.get('prefix') not in old_route]
                        config_temp.append('up ip -{0} route add {1} via {2}'.format(
                            str(vmIp.get('version')), route.get('prefix'), route.get('nexthop')))
                    config_temp.extend(routes_config)

        _write_config_file(DebianNetworkConfigPersistOperator.config_file_path, '\n'.join(config_temp))

    @staticmethod
    def persist_config(nics):
        DebianNetworkConfigPersistOperator._create_zstack_config(nics)


def yaml_list_to_list(yaml_list_str):
    if '- ' not in yaml_list_str:
        pattern = re.compile(r'\[(.*?)\]', re.DOTALL)
        return [match.group(1).split(',') for match in pattern.finditer(yaml_list_str)][0]
    else:
        pattern = re.compile(r'^\s*-\s*(.*)$', re.MULTILINE)
        return [match.group(1) for match in pattern.finditer(yaml_list_str)]


def list_to_yaml_list(p_list, indent):
    yaml_str = ''
    for item in p_list:
        if isinstance(item, bool):
            yaml_str += '{0}- {1}\n'.format(indent, str(item).lower())
        else:
            yaml_str += '{0}- {1}\n'.format(indent, str(item))
    return yaml_str


def is_ipv4(ip_address):
    compile_ip = re.compile('^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)')
    if compile_ip.match(ip_address):
        return True
    else:
        return False


def get_prefix_len_by_netmask(netmask):
    '''
    :param netmask: netmask ip addr (eg: 255.255.255.0), or IPv4/IPv6 prefix length (e.g., '24' or '64')
    :return: equivalent cidr number to given netmask ip (eg: 24)
    '''
    if netmask.lower() == 'none':
        return 32
    if netmask.isdigit():
        prefix_len = int(netmask)
        if 0 <= prefix_len <= 128:
            return prefix_len
    return sum([bin(int(x)).count('1') for x in netmask.split('.')])


def header_indent_num(line):
    return len(line) - len(line.lstrip())


class NetplanNetworkConfigPersistOperator(NetworkConfigPersistOperatorBase):
    config_file_style = "/etc/netplan/"
    config_file_dir = "/etc/netplan/"
    config_file_name = '99-zstack-net-{0}.yaml'
    config_file_zstack = config_file_dir + config_file_name

    @staticmethod
    def _get_nic_name_by_config_file(file_name):
        match = re.search(r"99-zstack-net-(\w+).yaml$", file_name)
        if match:
            return match.group(1)
        return None

    @staticmethod
    def _clean_config_non_zstack(nics):
        def _append_nic_line():
            if len(nic_lines) > 1:
                new_lines.extend(nic_lines)
            elif len(nic_lines) == 1:
                new_lines.extend(nic_lines)
                new_lines.append('{0}{{}}'.format(' ' * (header_indent_num(nic_lines[0]) + 2)))

        files_list = os.listdir(NetplanNetworkConfigPersistOperator.config_file_dir)
        files_list = [file for file in files_list if '99-zstack-net' not in file
                      and os.path.splitext(file)[1] == '.yaml']
        if not files_list:
            return
        nic_names = [nic.get('nic_name') for nic in nics]

        for file in files_list:
            content = _read_config_file(NetplanNetworkConfigPersistOperator.config_file_dir + file)
            if not content or all([nic_name not in content for nic_name in nic_names]):
                continue
            context_nic_name = None
            context_nic_indent = 0
            lines = content.split('\n')
            new_lines = []
            nic_lines = []
            modify = False
            i = 0
            while i < len(lines):
                line = lines[i]
                indent = header_indent_num(line)
                nic_match = [nic_name for nic_name in nic_names if nic_name in line]

                if len(nic_match) > 0:
                    context_nic_name = nic_match[0]
                    context_nic_indent = indent
                    _append_nic_line()
                    nic_lines = [line]
                    i += 1
                    continue
                elif indent <= context_nic_indent and context_nic_name:
                    _append_nic_line()
                    nic_lines = []
                    context_nic_name = None
                    context_nic_indent = 0

                if context_nic_name:
                    if 'dhcp4' in line:
                        i += 1
                        modify = True
                        continue
                    if 'gateway4' in line:
                        modify = True
                        i += 1
                        continue
                    if 'nameservers' in line:
                        i += 1
                        modify = True
                        while i < len(lines) and header_indent_num(lines[i]) > indent:
                            i += 1
                        continue
                    if 'addresses' in line:
                        address_list_str = line + '\n'
                        i += 1
                        while i < len(lines) and '- ' in lines[i] and header_indent_num(lines[i]) >= indent:
                            address_list_str += lines[i] + '\n'
                            i += 1
                        address_list = yaml_list_to_list(address_list_str)
                        # keep ipv6 address
                        address_list_v6 = [address for address in address_list if not is_ipv4(address)]
                        if len(address_list) != len(address_list_v6):
                            modify = True

                        if len(address_list_v6) > 0:
                            nic_lines.append('{0}addresses:'.format(' ' * indent))
                            nic_lines.extend(['{0}- {1}'.format(' ' * indent, address) for address in address_list_v6])
                        continue
                    nic_lines.append(line)
                else:
                    new_lines.append(line)
                i += 1
            if modify:
                _append_nic_line()
                _write_config_file(NetplanNetworkConfigPersistOperator.config_file_dir + file, '\n'.join(new_lines))

    @staticmethod
    def _clean_zstack_config_file():
        files_list = os.listdir(NetplanNetworkConfigPersistOperator.config_file_dir)
        files_list = [file for file in files_list if '99-zstack-net' in file and os.path.splitext(file)[1] == '.yaml']
        if not files_list:
            return

        curr_port_list = _get_curr_port_list()
        for file in files_list:
            nic_name = NetplanNetworkConfigPersistOperator._get_nic_name_by_config_file(file)
            if nic_name and nic_name not in curr_port_list:
                os.remove(NetplanNetworkConfigPersistOperator.config_file_dir + file)

    @staticmethod
    def _clean_route_config(cur_nic, routes):
        files_list = os.listdir(NetplanNetworkConfigPersistOperator.config_file_dir)
        files_list = [file for file in files_list if '99-zstack-net' in file
                      and file != NetplanNetworkConfigPersistOperator.config_file_name.format(cur_nic)
                      and os.path.splitext(file)[1] == '.yaml']
        if not files_list:
            return

        prefixes = [route.get('prefix') for route in routes]
        for file in files_list:
            content = _read_config_file(NetplanNetworkConfigPersistOperator.config_file_dir + file)
            if not content or 'routes' not in content:
                continue

            new_lines = []
            modify = False
            for line in content.split('\n'):
                if 'routes' in line:
                    match = re.search(r"(\[.*\])", line)
                    if match:
                        routes_str = match.group(1)
                        routes_str = routes_str.replace(": ", "': '").replace(", ", "', '").replace("{", "{'")\
                            .replace("}", "'}")
                        cur_routes_list = ast.literal_eval(routes_str)
                        new_routes_list = [route_cur for route_cur in cur_routes_list if
                                           route_cur.get('to') not in prefixes]
                        if len(new_routes_list) == len(cur_routes_list):
                            break

                        modify = True
                        if len(new_routes_list) != 0:
                            routes_yaml = ['{{to: {0}, via: {1}}}'.format(route.get('to'), route.get('via')) for route
                                           in new_routes_list]
                            new_lines.append(
                                '{0}routes: [{1}]'.format(' ' * header_indent_num(line), ','.join(routes_yaml)))

                        else:
                            break
                    else:
                        break
                else:
                    new_lines.append(line)

            if modify:
                _write_config_file(NetplanNetworkConfigPersistOperator.config_file_dir + file, '\n'.join(new_lines))

    @staticmethod
    def _create_zstack_config(nics):
        config_temp = [ZSTACK_START_COMMENT]

        indent_base = '  '
        for nic in nics:
            config_temp.append('network:')
            config_temp.append('{0}version: 2'.format(indent_base))
            config_temp.append('{0}renderer: {1}'.format(indent_base, _get_network_config_service()))
            config_temp.append('{0}ethernets:'.format(indent_base))

            nic_name = nic.get('nic_name')
            for vmIp in nic['vmIps']:
                if '4' in str(vmIp.get('version')):
                    ip4 = vmIp
                if '6' in str(vmIp.get('version')):
                    ip6 = vmIp

            config_temp.append('{0}{1}:'.format(indent_base * 2, nic_name))
            config_temp.append('{0}match:'.format(indent_base * 3))
            config_temp.append('{0}macaddress: {1}'.format(indent_base * 4, nic.get('mac')))
            if nic.get('mtu'):
                config_temp.append('{0}mtu: {1}'.format(indent_base * 3, nic.get('mtu')))

            if ip4.get('proto') == 'static':
                config_temp.append('{0}dhcp4: no'.format(indent_base * 3))
                if ip4.get('ip') != 'none':
                    config_temp.append('{0}addresses:'.format(indent_base * 3))
                    config_temp.append('{0}- {1}'.format(indent_base * 3, '{0}/{1}'.format(ip4.get('ip'),
                                                                                   get_prefix_len_by_netmask(
                                                                                       ip4.get('netmask')))))
                    if ip4.get('gateway'):
                        config_temp.append('{0}gateway4: {1}'.format(indent_base * 3, ip4.get('gateway')))
            else:
                config_temp.append('{0}dhcp4: yes'.format(indent_base * 3))

            if ip6.get('proto') == 'static':
                config_temp.append('{0}dhcp6: no'.format(indent_base * 3))
                if ip6.get('ip') != 'none':
                    config_temp.append('{0}addresses:'.format(indent_base * 3))
                    config_temp.append(
                        '{0}- {1}'.format(indent_base * 3, '{0}/{1}'.format(ip6.get('ip'), ip6.get('netmask'))))
                    if ip6.get('gateway'):
                        config_temp.append('{0}gateway6: {1}'.format(indent_base * 3, ip6.get('gateway')))
                config_temp.append('{0}accept-ra: true'.format(indent_base * 3))
            else:
                config_temp.append('{0}dhcp6: yes'.format(indent_base * 3))
            dns_entries = None
            if nic.get('isDefault'):
                if ip4.get('dns'):
                    dns_entries = ip4.get('dns')
                elif ip6.get('dns'):
                    dns_entries = ip6.get('dns')
            if dns_entries:
                config_temp.append('{0}nameservers:'.format(indent_base * 3))
                config_temp.append('{0}addresses:'.format(indent_base * 4))
                config_temp.extend(['{0}- {1}'.format(indent_base * 4, dns) for dns in dns_entries])

            routes_ipv4 = ip4.get('routes')
            if routes_ipv4:
                routes_yaml_ipv4 = ['{{to: {0}, via: {1}}}'.format(route.get('prefix'), route.get('nexthop')) for route
                                    in routes_ipv4]
                config_temp.append('{0}routes: [{1}]'.format(indent_base * 3, ','.join(routes_yaml_ipv4)))
                NetplanNetworkConfigPersistOperator._clean_route_config(nic_name, routes_ipv4)

            routes_ipv6 = ip6.get('routes')
            if routes_ipv6:
                routes_yaml_ipv6 = ['{{to: {0}, via: {1}}}'.format(route.get('prefix'), route.get('nexthop')) for route
                                    in routes_ipv6]
                config_temp.append('{0}routes: [{1}]'.format(indent_base * 3, ','.join(routes_yaml_ipv6)))
                NetplanNetworkConfigPersistOperator._clean_route_config(nic_name, routes_ipv6)

            _write_config_file(NetplanNetworkConfigPersistOperator.config_file_zstack.format(nic_name),
                               '\n'.join(config_temp) + '\n')

    @staticmethod
    def persist_config(nics):
        NetplanNetworkConfigPersistOperator._clean_zstack_config_file()
        NetplanNetworkConfigPersistOperator._create_zstack_config(nics)
        NetplanNetworkConfigPersistOperator._clean_config_non_zstack(nics)


class FedoraNetworkConfigPersistOperator(NetworkConfigPersistOperatorBase):
    config_file_style = "/etc/sysconfig/network-scripts/"
    config_file_dir = config_file_style
    network_start_config = "ONBOOT=yes"
    network_ipv6_address_config = "IPV6ADDR"

    @staticmethod
    def _check_default_gateway(default_nic):
        if not default_nic:
            logger.debug("no need to check default gateway")
            return

        mac2name = _get_phy_interfaces()

        logger.debug("check default gateway, default nic {0}".format(default_nic))
        for mac in mac2name:
            if mac != default_nic.get('mac'):
                path = '{0}ifcfg-{1}'.format(FedoraNetworkConfigPersistOperator.config_file_dir, mac2name.get(mac))
                cmd = "sed -E -i '/gateway|IPV6_DEFAULTGW|dns/Id' {0} " \
                      "&& nohup ifdown {1} --force; ifup {1} --force 1>/dev/null 2>&1 &".format(path, mac2name.get(mac))
                _call_if_err_raise(cmd)

        # remove old default gateway
        shell.run("ip -4 route delete default")
        shell.run("ip -6 route delete default")
        shell.call("ip -4 route")
        shell.call("ip -6 route")

    @staticmethod
    def _clean_if_config(nics):
        files_list = os.listdir(FedoraNetworkConfigPersistOperator.config_file_dir)
        files_list = [file for file in files_list if os.path.basename(file)[0:6] == 'ifcfg-']
        if not files_list:
            return

        nic_names = [nic.get('nic_name') for nic in nics]
        nic_macs = [nic.get('mac') for nic in nics]
        files_need_check = [file for file in files_list if file.split('-')[1] not in nic_names]
        for file_name in files_need_check:
            path = '{0}{1}'.format(FedoraNetworkConfigPersistOperator.config_file_dir, file_name)
            config = _read_config_file(path)
            if not config:
                continue
            if any('DEVICE={0}'.format(nic_name) in config for nic_name in nic_names)\
                    or any('HWADDR={0}'.format(nic_mac) in config for nic_mac in nic_macs):
                os.remove(path)

    @staticmethod
    def _clean_route_config(cur_nic, routes):
        route_config_file = '{0}route-{1}'.format(FedoraNetworkConfigPersistOperator.config_file_dir, cur_nic)
        if not routes:
            if os.path.exists(route_config_file):
                os.remove(route_config_file)
            return

        files_list = os.listdir(FedoraNetworkConfigPersistOperator.config_file_dir)
        files_list = [file for file in files_list if os.path.basename(file)[0:6] == 'route-']
        if not files_list:
            return

        prefix = [route.get('prefix') for route in routes if route.get('prefix') and route.get('nexthop')]
        # files = [line.split('/')[4] for line in ret.split('\n') if len(line.split('/')) > 4]
        for file_name in files_list:
            if cur_nic in file_name:
                continue

            path = '{0}{1}'.format(FedoraNetworkConfigPersistOperator.config_file_dir, file_name)
            config = _read_config_file(path)
            if not config:
                continue

            new_config = []
            update = False
            for line in config.split('\n'):
                if line.split(' ')[0].strip() in prefix:
                    if ":" in line:
                        shell.run('ip -6 route del {0}'.format(line.strip()))
                    else:
                        shell.run('ip -4 route del {0}'.format(line.strip()))
                    update = True
                elif line.strip():
                    new_config.append(line.strip())
            if not update:
                continue
            if len(new_config) == 0:
                os.remove(path)
            else:
                _write_config_file(path, '\n'.join(new_config) + '\n')

    @staticmethod
    def _persist_routes(nic_name, routes):
        lines = []
        for route in routes:
            if route.get('prefix') and route.get('nexthop'):
                lines.append('{0} via {1}'.format(route.get('prefix'), route.get('nexthop')))
        if lines:
            new_config = '\n'.join(lines) + '\n'
            _write_config_file(
                '{0}route-{1}'.format(FedoraNetworkConfigPersistOperator.config_file_dir, nic_name), new_config)

    @staticmethod
    def _create_zstack_config(nics):
        default_nic = None
        for nic in nics:
            path = '{0}ifcfg-{1}'.format(FedoraNetworkConfigPersistOperator.config_file_dir, nic.get('nic_name'))
            for vmIp in nic['vmIps']:
                if '4' in str(vmIp.get('version')):
                    ip4 = vmIp
                if '6' in str(vmIp.get('version')):
                    ip6 = vmIp

            lines = [ZSTACK_START_COMMENT, 'NAME={0}'.format(nic.get('nic_name')), 'HWADDR={0}'.format(nic.get('mac')),
                     'DEVICE={0}'.format(nic.get('nic_name'))]
            if nic.get('mtu'):
                lines.append('MTU={0}'.format(nic.get('mtu')))
            if ip4.get('proto') == 'static' and ip4.get('ip') != 'none':
                lines.append('BOOTPROTO={0}'.format(ip4.get('proto')))
                lines.append('IPADDR={0}'.format(ip4.get('ip')))
                lines.append('NETMASK={0}'.format(ip4.get('netmask')))
                if ip4.get('gateway'):
                    lines.append('GATEWAY={0}'.format(ip4.get('gateway')))

            if ip6.get('proto') == 'static' and ip6.get('ip') != 'none':
                lines.append('IPV6INIT=yes')
                lines.append('IPV6_AUTOCONF=no')
                lines.append(
                    '{0}={1}'.format(
                        FedoraNetworkConfigPersistOperator.network_ipv6_address_config,
                        ip6.get('ip') + "/" + ip6.get('netmask')
                    )
                )
                if ip6.get('gateway'):
                    lines.append('IPV6_DEFAULTGW={0}'.format(ip6.get('gateway')))

            if nic.get('isDefault') and ip4.get('dns'):
                dns = ['DNS{0}={1}'.format(i + 1, addr) for i, addr in enumerate(ip4.get('dns'))] if ip4.get(
                    'dns') else []
                lines.extend(dns)
            elif nic.get('isDefault') and ip6.get('dns'):
                dns = ['DNS{0}={1}'.format(i + 1, addr) for i, addr in enumerate(ip6.get('dns'))] if ip6.get(
                    'dns') else []
                lines.extend(dns)
            if nic.get('isDefault'):
                default_nic = nic

            lines.append(FedoraNetworkConfigPersistOperator.network_start_config)
            lines.append('USERCTL=no')
            if nic.get('isDefault'):
                lines.append('PEERDNS=yes')
            else:
                lines.append('PEERDNS=no')
            new_content = '\n'.join(lines) + '\n'
            logger.info('write to file, path:{0}, content:{1}'.format(path, new_content))
            _write_config_file(path, new_content)
            # route-ethx must be created after ifcfg-ethx is created
            routes = []
            if ip4.get('routes') is not None:
                routes += ip4.get('routes')
            if ip6.get('routes') is not None:
                routes += ip6.get('routes')
                
            FedoraNetworkConfigPersistOperator._clean_route_config(nic.get('nic_name'), routes)
            if routes:
                FedoraNetworkConfigPersistOperator._persist_routes(nic.get('nic_name'), routes)

        return default_nic

    @staticmethod
    def persist_config(nics):
        FedoraNetworkConfigPersistOperator._clean_if_config(nics)
        default_nic = FedoraNetworkConfigPersistOperator._create_zstack_config(nics)
        FedoraNetworkConfigPersistOperator._check_default_gateway(default_nic)


class SuseNetworkConfigPersistOperator(FedoraNetworkConfigPersistOperator):
    config_file_style = "/etc/sysconfig/network/"
    network_start_config = "STARTMODE=auto"
    network_ipv6_address_config = "IPADDR_IPV6"


    @staticmethod
    def _persist_gateway(nics):
        default_nic = None
        for nic in nics:
            if nic.get('isDefault'):
                default_nic = nic
                break
        if not default_nic:
            logger.debug("no need to persist default gateway")
            return

        routes_path = os.path.join(SuseNetworkConfigPersistOperator.config_file_dir, 'routes')
        backup_routes_cmd = ('[ -f %(routes_path)s ] && cp %(routes_path)s %(routes_path)s.bak || touch %(routes_path)s'
                             % {'routes_path': routes_path})
        _call_if_err_raise(backup_routes_cmd)

        route_cmds = []
        for vmIp in default_nic['vmIps']:
            if '4' in str(vmIp.get('version')) and vmIp.get('gateway'):
                route_cmds.append('echo "default %s - -" >> %s' % (vmIp.get('gateway'), routes_path))
            if '6' in str(vmIp.get('version')) and vmIp.get('gateway'):
                route_cmds.append('echo "default %s - -" >> %s' % (vmIp.get('gateway'), routes_path))
        if route_cmds:
            clear_cmd = 'echo -n "" > %s' % routes_path
            all_cmds = ' && '.join([clear_cmd] + route_cmds)
            _call_if_err_raise(all_cmds)

        logger.debug("Suse default gateways persisted to %s" % routes_path)

    @staticmethod
    def persist_config(nics):
        FedoraNetworkConfigPersistOperator.config_file_dir = SuseNetworkConfigPersistOperator.config_file_style
        FedoraNetworkConfigPersistOperator.network_start_config = SuseNetworkConfigPersistOperator.network_start_config
        FedoraNetworkConfigPersistOperator.network_ipv6_address_config = SuseNetworkConfigPersistOperator.network_ipv6_address_config
        FedoraNetworkConfigPersistOperator.persist_config(nics)
        SuseNetworkConfigPersistOperator._persist_gateway(nics)


class NetworkConfigReloadOperatorBase:
    ''''''

    @staticmethod
    def _reload_dns_config_static(dns_list):
        if not dns_list:
            return
        lines = [ZSTACK_START_COMMENT]
        for dns in dns_list:
            lines.append('nameserver {0}'.format(dns))
        content = '\n'.join(lines) + '\n'
        _write_config_file('/etc/resolv.conf', content)


class NmcliNetworkConfigReloadOperator(NetworkConfigReloadOperatorBase):
    ''' use nmcli to reload network config '''

    @staticmethod
    def reload_config(nics):
        nic_names = []
        nic_flush_names = []
        for nic in nics:
            if len(nic['vmIps']) > 0:
                for ip in nic['vmIps']:
                    if '4' in str(ip.get('version')) and ip.get('ip') != 'none':
                        nic_names.append(nic.get('nic_name'))
                        continue
                    if '6' in str(ip.get('version')) and ip.get('ip') != 'none':
                        nic_names.append(nic.get('nic_name'))
                        continue
                    nic_flush_names.append(nic.get('nic_name'))
        cmd = 'nmcli conn reload'
        _call_if_err_raise(cmd)
        for nic_name in set(nic_flush_names):
            cmd = 'ip -4 address flush dev {0}'.format(nic_name)
            _call_if_err_raise(cmd)
            cmd = 'ip -6 address flush dev {0}'.format(nic_name)
            _call_if_err_raise(cmd)
            logger.info('reload nic:{0} config'.format(nic_name))
            cmd = 'nmcli conn down {0}; nmcli conn up {1}'.format(nic_name, nic_name)
            _call_if_err_raise(cmd)
        for nic_name in nic_names:
            logger.info('reload nic:{0} config'.format(nic_name))
            cmd = 'nmcli conn down {0}; nmcli conn up {1}'.format(nic_name, nic_name)
            _call_if_err_raise(cmd)

    @staticmethod
    def old_reload_config(nics):
        # low version nmcli(NetworkManager) need restart nic manually
        nic_names = [nic.get('nic_name') for nic in nics]

        for nic_name in nic_names:
            logger.info('reload nic:{0} config'.format(nic_name))
            path = '{0}ifcfg-{1}'.format(FedoraNetworkConfigPersistOperator.config_file_dir, nic_name)
            cmd = "grep -q 'NM_CONTROLLED=no' {0} || sed -i -e '$aNM_CONTROLLED=no' {0}".format(path)
            if os.path.exists(path):
                _call_if_err_raise(cmd)
            cmd = 'ip -4 address flush dev {0}'.format(nic_name)
            _call_if_err_raise(cmd)
            cmd = 'ip -6 address flush dev {0}'.format(nic_name)
            _call_if_err_raise(cmd)
            cmd = 'nohup sh -c \'ifdown {0} --force; sleep 5; ifup {0} --force\' > /dev/null 2>&1 &'.format(nic_name)
            _call_if_err_raise(cmd)

        for nic in nics:
            if nic.get('isDefault'):
                nic_path = '{0}{1}'.format(FedoraNetworkConfigPersistOperator.config_file_dir, 'ifcfg-'+nic.get('nic_name'))
                dns_path = '/etc/resolv.conf'
                cmd = (
                    'chattr -i {1} && '
                    'awk -F= \'/^DNS[0-9]+/ {{ print "nameserver " $2 }}\' {0} > {1} && '
                    'chattr +i {1}'
                ).format(nic_path, dns_path)
                _call_if_err_raise(cmd)


def _read_config_file(path):
    if not os.path.exists(path):
        return ""

    with open(path) as f:
        return f.read()


def _write_config_file(path, content):
    backup_path = '{0}.bak'.format(path)
    if os.path.exists(path) and not os.path.exists(backup_path):
        with open(path, 'r') as original_file:
            backup_content = original_file.read()
        with open(backup_path, 'w') as backup_file:
            logger.debug('backup config file, path{0}, content={1}'.format(backup_path, backup_content))
            backup_file.write(backup_content)
    with open(path, 'w') as f:
        f.write(content)


def _stop_dhcp_client(nic_name):
    bash_cmd = '''#!/bin/bash
    # stop dhclient
    cur_dhclient=$(ps aux | grep dhclient | grep -v 'bash -c' | grep {nic_name})
    if [[ $cur_dhclient != "" ]]; then
        pf=""
        pf=$(echo $cur_dhclient | awk -F '-pf' '{{print $2}}' | awk -F ' ' '{{print $1}}')
        if [[ $pf != "" ]]; then
            pf="-pf "$pf
        fi

        $(which dhclient) -r {nic_name} $pf 2> /dev/null
    fi '''
    shell.run(bash_cmd.format(nic_name=nic_name))


def _start_dhcp_client(nic_name):
    cmd = '$(which dhclient) -1 -v -pf /run/dhclient.{nic_name}.pid -lf /var/lib/dhcp/dhclient.{nic_name}.leases ' +\
          '-I {nic_name} 2> /dev/null '.format(nic_name=nic_name)
    shell.run(cmd)


def _config_nic_ip_address(nic_name, ip_address, prefix_len, ip_version):
    if ip_address.lower() == 'none':
        cmd = '''
ip -{ip_version} address flush dev {nic_name}
'''
        shell.run(cmd.format(nic_name=nic_name, ip_version=ip_version))
    else:
        cmd = '''
if [[ $(ip addr ls dev {nic_name} | grep {ip_address}/{prefix_len}) == "" ]];then
    ip -{ip_version} address flush dev {nic_name}
    ip -{ip_version} address add {ip_address}/{prefix_len} dev {nic_name}
fi
'''
        shell.run(cmd.format(nic_name=nic_name, ip_address=ip_address, prefix_len=prefix_len, ip_version=ip_version))


def _config_nic_gateway(nic_name, gateway, version):
    cmd = '''
if [[ $(ip -{version} route | grep "default via {gateway} dev {nic_name}") == "" ]];then
    ip -{version} route add default via {gateway} dev {nic_name}
fi
'''
    shell.run(cmd.format(nic_name=nic_name, gateway=gateway, version=version))


def _config_nic_route(nic_name, prefix, nexthop, version):
    cmd = '''
if [[ $(ip -{version} route show {prefix} via {nexthop} dev {nic_name} | grep -c '^') -eq 0 ]]; then
    if [[ $(ip -{version} route show {prefix} | grep -c '^') -ne 0 ]]; then
        ip -{version} route del {prefix}
    fi

    ip -{version} route add {prefix} via {nexthop} dev {nic_name}
fi
'''
    shell.run(cmd.format(nic_name=nic_name, prefix=prefix, nexthop=nexthop, version=version))


def _config_nic_mtu(nic_name, mtu):
    cmd = 'ip link set mtu {mtu} dev {nic_name}'
    shell.run(cmd.format(nic_name=nic_name, mtu=mtu))


def _set_nic_up_down(nic_name, up=True):
    if up:
        cmd = 'ip link set up dev {nic_name}'
    else:
        cmd = 'ip link set down dev {nic_name}'
    shell.run(cmd.format(nic_name=nic_name))


class IprouteNetworkConfigReloadOperator(NetworkConfigReloadOperatorBase):
    ''' use iproute to reload network config '''

    @staticmethod
    def reload_config(nics):
        for nic in nics:
            nic_name = nic.get('nic_name')
            _stop_dhcp_client(nic_name)
            _set_nic_up_down(nic_name)

            if nic.get('mtu'):
                _config_nic_mtu(nic_name, nic.get('mtu'))
            for vmIp in nic['vmIps']:
                if vmIp.get('proto') == 'static':
                    _config_nic_ip_address(nic_name, vmIp.get('ip'), get_prefix_len_by_netmask(vmIp.get('netmask')), str(vmIp.get('version')))
                else:
                    _start_dhcp_client(nic_name)
                if vmIp.get('ip').lower() == 'none':
                    continue
                if vmIp.get('gateway'):
                    _config_nic_route(nic_name, 'default', vmIp.get('gateway'), str(vmIp.get('version')))
                if nic.get('isDefault') and vmIp.get('dns') and vmIp.get('proto') == 'static':
                    NetworkConfigReloadOperatorBase._reload_dns_config_static(vmIp.get('dns'))
                if vmIp.get('routes'):
                    for route in vmIp.get('routes'):
                        _config_nic_route(nic_name, route.get('prefix'), route.get('nexthop'), str(vmIp.get('version')))


class NetplanNetworkConfigReloadOperator(NetworkConfigReloadOperatorBase):
    @staticmethod
    def reload_config(nics):
        _call_if_err_raise('netplan apply')


############################################################################


def _get_os_info():
    with open('/etc/os-release') as f:
        content = f.read()
        lines = content.split('\n')
        os_id = None
        os_version_id = None
        for line in lines:
            match_ret = re.match('^[\s\t]*id=(.*)', line, re.IGNORECASE)
            if match_ret:
                os_id = match_ret.group(1).replace('"', '')
            match_ret = re.match('^[\s\t]*version_id=(.*)', line, re.IGNORECASE)
            if match_ret:
                os_version_id = match_ret.group(1).replace('"', '')
                os_version_id = os_version_id.split('.')[0]
        return os_id, os_version_id


def _get_phy_interfaces():
    ret = _call_if_err_raise('ls -l /sys/class/net/*/device')
    if not ret:
        return None
    '''
    the format of "ret" like this:
    lrwxrwxrwx 1 root root 0 Nov 21 18:04 /sys/class/net/enp101s0f0/device -> ../../../0000:65:00.0
    '''
    phy_interfaces = [line.split('/')[4] for line in ret.split('\n') if len(line.split('/')) > 5]
    path_list = ['/sys/class/net/%s/address' % interface for interface in phy_interfaces]
    ret = _call_if_err_raise('cat ' + ' '.join(path_list))
    if not ret:
        return None

    mac_list = [mac for mac in ret.split('\n') if ':' in mac]
    if len(phy_interfaces) != len(mac_list):
        raise ConfigException(
            'get vm physical interface failed, nic names:{0}, nic macs:{1}'.format(phy_interfaces, mac_list))

    return dict(zip(mac_list, phy_interfaces))


def _set_nic_name_for_config(nics):
    def update_nic_names():
        phy_interfaces = _get_phy_interfaces()
        logger.info('current system nics: {0}'.format(phy_interfaces))
        for nic in nics:
            if nic.get('mac') not in phy_interfaces:
                logger.info('nic with MAC {0} not found'.format(nic.get('mac')))
                return False
            nic['nic_name'] = phy_interfaces[nic.get('mac')]
        return True

    if not update_nic_names():
        logger.info('nic not found, performing rescan and retrying...')
        _call_if_err_raise('echo 1 > /sys/bus/pci/rescan')
        if not update_nic_names():
            raise ConfigException('get VM physical nic with MAC failed after rescan')
    logger.info(nics)


def _get_network_config_netplan_info():
    use_netplan = False
    if shell.run('which netplan'):
        use_netplan = True
    return use_netplan


def _get_network_config_service():
    if shell.run('which pgrep'):
        if shell.run('pgrep -f NetworkManager'):
            return 'NetworkManager'
        elif shell.run('pgrep -f systemd-networkd'):
            return 'networkd'
    else:
        if shell.run('ps -C NetworkManager | grep NetworkManager'):
            return 'NetworkManager'
        elif shell.run('ps -C systemd-networkd | grep systemd-network'):
            return 'networkd'
    return None


def _get_network_config_persist_style(os_id, os_version_id):
    if os.path.exists(FedoraNetworkConfigPersistOperator.config_file_style):
        return FedoraNetworkConfigPersistOperator.config_file_style
    if os.path.exists(SuseNetworkConfigPersistOperator.config_file_style):
        return SuseNetworkConfigPersistOperator.config_file_style
    elif os.path.exists(DebianNetworkConfigPersistOperator.config_file_style):
        return DebianNetworkConfigPersistOperator.config_file_style
    else:
        raise ConfigException('not supported os: {0} {1}'.format(os_id, os_version_id))


############################################################################

def _init_nw_config_func_table():
    persist_fedora = FedoraNetworkConfigPersistOperator.persist_config
    persist_suse = SuseNetworkConfigPersistOperator.persist_config
    persist_debian = DebianNetworkConfigPersistOperator.persist_config
    persist_netplan = NetplanNetworkConfigPersistOperator.persist_config

    nmcli_reload = NmcliNetworkConfigReloadOperator.reload_config
    iproute_reload = IprouteNetworkConfigReloadOperator.reload_config
    netplan_reload = NetplanNetworkConfigReloadOperator.reload_config
    old_nmcli_reload = NmcliNetworkConfigReloadOperator.old_reload_config

    style_fedora = FedoraNetworkConfigPersistOperator.config_file_style
    style_suse = SuseNetworkConfigPersistOperator.config_file_style
    style_debian = DebianNetworkConfigPersistOperator.config_file_style
    style_netplan = NetplanNetworkConfigPersistOperator.config_file_style

    g_nw_config_func_tbl.extend(
        [NwConfigFuncTableRecord('kylin', 'V10', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('kylin', 'V10', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('neokylin', 'V7', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('neokylin', 'V7', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('neokylin', 'V7Update6', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('neokylin', 'V7Update6', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('kylin', '4', False, 'NetworkManager', style_debian, persist_debian, old_nmcli_reload),
         NwConfigFuncTableRecord('kylin', '4', False, None, style_debian, persist_debian, iproute_reload),
         NwConfigFuncTableRecord('kylin', '4', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('kylin', '4', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('uos', '20', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('uos', '20', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('centos', '6', False, 'NetworkManager', style_fedora, persist_fedora, old_nmcli_reload),
         NwConfigFuncTableRecord('centos', '6', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('centos', '7', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('centos', '7', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('centos', '8', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('centos', '8', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('centos', '9', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('centos', '9', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('opensuse-leap', '11', False, 'NetworkManager', style_suse, persist_suse,
                                 nmcli_reload),
         NwConfigFuncTableRecord('opensuse-leap', '11', False, None, style_suse, persist_suse, iproute_reload),
         NwConfigFuncTableRecord('sles', '11', False, 'NetworkManager', style_suse, persist_suse, nmcli_reload),
         NwConfigFuncTableRecord('sles', '11', False, None, style_suse, persist_suse, iproute_reload),
         NwConfigFuncTableRecord('sled', '11', False, 'NetworkManager', style_suse, persist_suse, nmcli_reload),
         NwConfigFuncTableRecord('sled', '11', False, None, style_suse, persist_suse, iproute_reload),
         NwConfigFuncTableRecord('opensuse-leap', '12', False, 'NetworkManager', style_suse, persist_suse,
                                 nmcli_reload),
         NwConfigFuncTableRecord('opensuse-leap', '12', False, None, style_suse, persist_suse, iproute_reload),
         NwConfigFuncTableRecord('sles', '12', False, 'NetworkManager', style_suse, persist_suse, nmcli_reload),
         NwConfigFuncTableRecord('sles', '12', False, None, style_suse, persist_suse, iproute_reload),
         NwConfigFuncTableRecord('sled', '12', False, 'NetworkManager', style_suse, persist_suse, nmcli_reload),
         NwConfigFuncTableRecord('sled', '12', False, None, style_suse, persist_suse, iproute_reload),
         NwConfigFuncTableRecord('opensuse-leap', '15', False, 'NetworkManager', style_suse, persist_suse,
                                 nmcli_reload),
         NwConfigFuncTableRecord('opensuse-leap', '15', False, None, style_suse, persist_suse, iproute_reload),
         NwConfigFuncTableRecord('sles', '15', False, 'NetworkManager', style_suse, persist_suse, nmcli_reload),
         NwConfigFuncTableRecord('sles', '15', False, None, style_suse, persist_suse, iproute_reload),
         NwConfigFuncTableRecord('sled', '15', False, 'NetworkManager', style_suse, persist_suse, nmcli_reload),
         NwConfigFuncTableRecord('sled', '15', False, None, style_suse, persist_suse, iproute_reload),
         NwConfigFuncTableRecord('ol', '7', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('ol', '7', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('rhel', '7', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('rhel', '7', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('rhel', '8', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('rhel', '8', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('rhel', '9', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('rhel', '9', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('anolis', '7', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('anolis', '7', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('anolis', '8', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('anolis', '8', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('ubuntu', '24', True, 'NetworkManager', style_netplan, persist_netplan, netplan_reload),
         NwConfigFuncTableRecord('ubuntu', '24', True, 'networkd', style_netplan, persist_netplan, netplan_reload),
         NwConfigFuncTableRecord('ubuntu', '22', True, 'NetworkManager', style_netplan, persist_netplan, netplan_reload),
         NwConfigFuncTableRecord('ubuntu', '22', True, 'networkd', style_netplan, persist_netplan, netplan_reload),
         NwConfigFuncTableRecord('ubuntu', '20', True, 'NetworkManager', style_netplan, persist_netplan, netplan_reload),
         NwConfigFuncTableRecord('ubuntu', '20', True, 'networkd', style_netplan, persist_netplan, netplan_reload),
         NwConfigFuncTableRecord('ubuntu', '18', True, 'NetworkManager', style_netplan, persist_netplan,
                                 netplan_reload),
         NwConfigFuncTableRecord('ubuntu', '18', True, 'networkd', style_netplan, persist_netplan, netplan_reload),
         NwConfigFuncTableRecord('ubuntu', '14', False, None, style_debian, persist_debian, iproute_reload),
         NwConfigFuncTableRecord('ubuntu', '14', True, None, style_netplan, persist_debian, iproute_reload),
         NwConfigFuncTableRecord('ubuntu', '14', True, 'NetworkManager', style_netplan, persist_netplan,
                                 netplan_reload),
         NwConfigFuncTableRecord('ubuntu', '14', True, 'networkd', style_netplan, persist_netplan, netplan_reload),
         NwConfigFuncTableRecord('ubuntu', '16', False, None, style_debian, persist_debian, iproute_reload),
         NwConfigFuncTableRecord('ubuntu', '16', True, None, style_netplan, persist_debian, iproute_reload),
         NwConfigFuncTableRecord('ubuntu', '16', True, 'NetworkManager', style_netplan, persist_netplan,
                                 netplan_reload),
         NwConfigFuncTableRecord('ubuntu', '16', True, 'networkd', style_netplan, persist_netplan, netplan_reload),
         NwConfigFuncTableRecord('debian', '9', False, None, style_debian, persist_debian, iproute_reload),
         NwConfigFuncTableRecord('debian', '9', False, 'NetworkManager', style_debian, persist_debian,
                                 old_nmcli_reload),
         NwConfigFuncTableRecord('debian', '10', False, None, style_debian, persist_debian, iproute_reload),
         NwConfigFuncTableRecord('debian', '10', False, 'NetworkManager', style_debian, persist_debian,
                                 old_nmcli_reload),
         NwConfigFuncTableRecord('debian', '11', False, None, style_debian, persist_debian, iproute_reload),
         NwConfigFuncTableRecord('debian', '11', False, 'NetworkManager', style_debian, persist_debian,
                                  old_nmcli_reload),
         NwConfigFuncTableRecord('debian', '12', False, None, style_debian, persist_debian, iproute_reload),
         NwConfigFuncTableRecord('debian', '12', False, 'NetworkManager', style_debian, persist_debian,
                               old_nmcli_reload),
         NwConfigFuncTableRecord('fedora', '30', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('fedora', '30', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('fedora', '31', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('fedora', '31', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('openEuler', '20', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('openEuler', '20', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('openEuler', '22', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('openEuler', '22', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('rocky', '8', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('rocky', '8', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('rocky', '9', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('rocky', '9', False, None, style_fedora, persist_fedora, iproute_reload),
         NwConfigFuncTableRecord('almalinux', '9', False, 'NetworkManager', style_fedora, persist_fedora, nmcli_reload),
         NwConfigFuncTableRecord('almalinux', '9', False, None, style_fedora, persist_fedora, iproute_reload),
         ]
    )


#############################################################################

def _config_network(nics):
    if not nics:
        return

    logger.info(nics)

    os_id, os_version_id = _get_os_info()
    logger.debug("os_id:{0}, os_version_id:{1}".format(os_id, os_version_id))

    service = _get_network_config_service()
    logger.debug("service: {0}".format(service))

    use_netplan = _get_network_config_netplan_info()

    persist_style = NetplanNetworkConfigPersistOperator.config_file_style if use_netplan\
        else _get_network_config_persist_style(os_id, os_version_id)
    logger.debug("persist_style: {0}".format(persist_style))

    func_record = _get_nw_config_func_record(os_id=os_id,
                                             os_version_id=os_version_id,
                                             use_netplan=use_netplan,
                                             service=service,
                                             persist_style=persist_style)

    _set_nic_name_for_config(nics)
    func_record.persist_func(nics)
    func_record.reload_func(nics)


#############################################################################

def _load_config_arguments(path):
    with open(path, 'r') as fp:
        return json.load(fp)


def _output_result_to_caller(ret):
    print(ret)


@utils.retry(times=3, sleep_time=5)
def _retry_find_expect_nics_by_mac(mac, ha_state):
    if not mac:
        raise ConfigException('mac is invalid')
    all_nics = utils.find_nic_list_by_mac(mac)
    physical_nics = []
    nic_dict = {}
    for n in all_nics:
        if not utils.is_device_exists(n):
            raise ConfigException('could not find nic: %s, will retry again' % n)
        if utils.is_bond(n):
            nic_dict['bond'] = n
            continue
        physical_nics.append(n)

    if ha_state == netconfig.NET_CONFIG_HA_STATE_ENABLED:
        if len(physical_nics) < 2:
            raise ConfigException('could not find enough physical nics for ha state: %s' % ha_state)
        for n in physical_nics:
            if utils.is_virtio_nic(n):
                nic_dict['standby'] = n
            else:
                nic_dict['master'] = n
    else:
        if len(physical_nics) != 1:
            raise ConfigException('could not find enough physical nics for ha state: %s' % ha_state)
        nic_dict['master'] = physical_nics[0]

    logger.info('find nic list by mac[%s]: %s' % (mac, all_nics))
    return nic_dict


def _config_nics_with_enable_ha(nics):
    if not nics:
        return
    logger.info('enable ha nics: %s' % nics)
    net_service = netconfig.get_system_network_service()
    service_type = net_service['type']
    service_config_path = net_service['path']
    for nic in nics:
        nic_dict = _retry_find_expect_nics_by_mac(nic.get('mac'), nic.get('haState'))
        if not nic_dict:
            raise ConfigException('could not find target nics by mac: {0}'.format(nic.get('mac')))

        # delete old bond config
        if 'bond' in nic_dict:
            bond_name = nic_dict['bond']
            if service_config_path == netconfig.DEFAULT_CONFIG_PATH:
                os.remove('{}/ifcfg-{}'.format(service_config_path, bond_name))
                if service_type == netconfig.NET_SERVICE_TYPE_NMCLI:
                    shell.run('nmcli c delete {}'.format(bond_name))

        if 'master' not in nic_dict:
            raise ConfigException('could not find master nic by mac: {0}'.format(nic.get('mac')))

        # create nic config
        nic_config = netconfig.NetConfig(name=nic_dict['master'],
                        link_type=netconfig.NET_CONFIG_ETHER_TYPE,
                        service_type=service_type,
                        config_path=service_config_path)
        nic_config.mtu = nic.get('mtu')
        nic_config.mac = nic.get('mac')
        if 'standby' in nic_dict:
            nic_config.standby_nic_name = nic_dict['standby']

        for ip in nic['vmIps']:
            if not ip.get('ip') or ip.get('ip').lower() == 'none':
                continue
            nic_config.add_ip_config(ip.get('ip'), ip.get('netmask'),
                    version=ip.get('version'), gateway=ip.get('gateway') if ip.get('gateway') else None)
            if ip.get('dns') and nic.get('isDefault'):
                for dns in ip.get('dns'):
                    nic_config.add_dns_config(dns)
            if ip.get('routes'):
                for route in ip.get('routes'):
                    nic_config.add_route_config(route.get('prefix'), route.get('nexthop'), dev=None, version=ip.get('version'))

        nic_config.common_config_network(ha_state=nic.get('haState'))
        shell.run('ip addr show')
        shell.run('ip r show')


if __name__ == "__main__":

    ret = {}
    try:
        data = utils.load_json_from_file(CONFIG_ARGUMENTS_PATH)
        nics = data.get('ports', [])

        normal_nics = []
        enable_ha_nics = []
        for nic in nics:
            if nic.get('haState') != netconfig.NET_CONFIG_HA_STATE_DISABLED:
                enable_ha_nics.append(nic)
            else:
                normal_nics.append(nic)

        # create bond and config
        _config_nics_with_enable_ha(enable_ha_nics)

        # config normal nics
        _init_nw_config_func_table()
        _config_network(normal_nics)

        ret['result'] = 'success'
    except Exception as e:
        log_exce_traceback()
        err_msg = str(e)
        logger.error(err_msg)
        ret['result'] = 'failed'
        ret['err_msg'] = err_msg
    finally:
        _output_result_to_caller(json.dumps(ret))
